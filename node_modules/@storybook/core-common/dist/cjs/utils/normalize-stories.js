"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeStories = exports.normalizeDirectory = exports.normalizeStoriesEntry = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var DEFAULT_FILES = '*.stories.@(mdx|tsx|ts|jsx|js)';
var DEFAULT_TITLE_PREFIX = '';

var isDirectory = function (configDir, entry) {
  try {
    return _fs.default.lstatSync(_path.default.resolve(configDir, entry)).isDirectory();
  } catch (err) {
    return false;
  }
};

var normalizeStoriesEntry = function (entry, configDir) {
  var glob;
  var directory;
  var files;
  var titlePrefix;

  if (typeof entry === 'string') {
    if (!entry.includes('**') && isDirectory(configDir, entry)) {
      directory = entry;
      titlePrefix = DEFAULT_TITLE_PREFIX;
      files = DEFAULT_FILES;
    } else {
      glob = entry;
    }
  } else {
    directory = entry.directory;
    files = entry.files || DEFAULT_FILES;
    titlePrefix = entry.titlePrefix || DEFAULT_TITLE_PREFIX;
  }

  if (typeof glob !== 'undefined') {
    return {
      glob: glob,
      specifier: undefined
    };
  }

  return {
    glob: `${directory}/**/${files}`,
    specifier: {
      directory: directory,
      titlePrefix: titlePrefix,
      files: files
    }
  };
};

exports.normalizeStoriesEntry = normalizeStoriesEntry;

/**
 * Stories entries are specified relative to the configDir. Webpack filenames are produced relative to the
 * current working directory. This function rewrites the specifier.directory relative to the current working
 * directory.
 */
var normalizeDirectory = function (entry, {
  configDir: configDir,
  workingDir: workingDir
}) {
  if (!entry.specifier) return entry;
  var directory = entry.specifier.directory;

  var directoryFromConfig = _path.default.resolve(configDir, directory);

  var directoryFromWorking = _path.default.relative(workingDir, directoryFromConfig); // relative('/foo', '/foo/src') => 'src'
  // but we want `./src`to match webpack's file names


  if (!directoryFromWorking.startsWith('.')) {
    directoryFromWorking = `.${_path.default.sep}${directoryFromWorking}`;
  }

  return _objectSpread(_objectSpread({}, entry), {}, {
    specifier: _objectSpread(_objectSpread({}, entry.specifier), {}, {
      directory: directoryFromWorking
    })
  });
};

exports.normalizeDirectory = normalizeDirectory;

var normalizeStories = function (entries, options) {
  return entries.map(function (entry) {
    return normalizeDirectory(normalizeStoriesEntry(entry, options.configDir), options);
  });
};

exports.normalizeStories = normalizeStories;